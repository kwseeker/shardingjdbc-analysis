# ShardingJdbc源码分析

## 核心类

### ShardingRule

配置的分库分表规则和策略几乎都在这个类中维护。

有几点实现比较重要：

+ **逻辑表到物理表的映射规则**

  获取ShardingRuleConfiguration中的TableRuleConfiguration（集合）配合数据源分片[分库]集合，使用InlineExpressionParser解析物理表的内嵌表达式（actualDataNodes），解析规则参考TableRule$splitAndEvaluate(), 最终获取逻辑表对应的物理表的“库名.表名”的集合。

+ **分库分表后如何生成唯一ID**

  生成唯一ID的接口类4.0.1版本是ShardingKeyGenerator;  
  
  实现类4.0.1版本只提供了两个实现类，SnowflakeShardingKeyGenerator是依靠雪花算法的实现，UUIDShardingKeyGenerator是依靠JDK UUID的实现。

  ++实现++：  
  1）新建KeyGeneratorConfiguration对象，通过构造方法指定生成主键唯一ID的算法类型（SNOWFLAKE、UUID）和主键列名；  
  2）将KeyGeneratorConfiguration对象赋值给TableRuleConfiguration的成员；  
  3）ShardingKeyGenerator的两种实现是通过SPI导入的；  
  4）执行insert语句的时候，在分片路由过程中生成主键唯一ID时。

  ++调试入口++：  
  通过ShardingDataSource实例创建ShardingStatement实例，然后执行ShardingStatement$executeUpdate()方法；
  ```java
  clearPrevious();
  //sql路由
  //1)首先获取分片上下文（目标数据库的元数据[数据库的地址，用户名等]，分片规则，系统属性，执行引擎，Schema、Table的元信息等）
  //2)新建Statement的路由引擎（就是使用分片上下文信息的规则策略决定这个Statement应该连接哪个物理数据库，在哪个物理表上操作）
  //3)先做分片路由再做主从路由
  //3.1)分片路由：
  //3.1.1)分片路由第一步就是生成唯一ID:
  //      首先判断语句是否为INSERT语句；
  //      获取要插入数据的表的TableRule实例，进而获取KeyGenerator实例，如果为空则使用DefaultKeyGenerator生成唯一ID
  //      DefaultKeyGenerator生成唯一ID的方式是雪花算法
  //其他不相关的逻辑后面有需要再分析...
  sqlRoute(sql);
  initStatementExecutor();
  return statementExecutor.executeUpdate(autoGeneratedKeys);
  ```
  ++从源码中抽离出来的生成唯一主键ID的代码++：
  ```
  @Test
  public void testGenerateKey() {
      //配置阶段
      KeyGeneratorConfiguration keyGeneratorConfig = new KeyGeneratorConfiguration("SNOWFLAKE", "order_id");
      //KeyGeneratorConfiguration keyGeneratorConfig = new KeyGeneratorConfiguration("UUID", "order_id");
      TableRuleConfiguration tableRuleConfiguration = new TableRuleConfiguration("yourLogicTable", "yourActualDataNodes");
      tableRuleConfiguration.setKeyGeneratorConfig(keyGeneratorConfig);
      //解析阶段
      ShardingKeyGenerator shardingKeyGenerator;  //这个是TableRule的成员变量shardingKeyGenerator
      if(null != tableRuleConfiguration.getKeyGeneratorConfig()
              && !Strings.isNullOrEmpty(tableRuleConfiguration.getKeyGeneratorConfig().getType())) {
          shardingKeyGenerator = (new ShardingKeyGeneratorServiceLoader()).newService(
                  tableRuleConfiguration.getKeyGeneratorConfig().getType(),
                  tableRuleConfiguration.getKeyGeneratorConfig().getProperties());
      } else {
          shardingKeyGenerator = null;
      }
      //路由阶段,生成主键唯一ID
      Long keyID = null;
      if(shardingKeyGenerator != null) {
          keyID = (Long)shardingKeyGenerator.generateKey();

      } else {
          //使用默认的ShardingKeyGenerator，即SPI文件org.apache.shardingsphere.spi.keygen.ShardingKeyGenerator中指定的第一个实现类
          //即默认就是 org.apache.shardingsphere.core.strategy.keygen.SnowflakeShardingKeyGenerator
          try {
              keyID = (Long)SnowflakeShardingKeyGenerator.class.newInstance().generateKey();
          } catch (InstantiationException | IllegalAccessException e) {
              e.printStackTrace();
          }
      }
      System.out.println(keyID);
  }
  ```

  唯一ID = 41bit时间戳 + 11bit机器id + 11bit自增序列

+ **分库策略、分表策略**

+ **主从规则**

+ **绑定表**

### SQLRouteResult


## 工作流程分析

SQL执行流程基本分为6个步骤：

1）解析
2）优化
3）路由
4）改写
5）执行
6）归并

打断点看调用栈。

1) 入口（以执行insert语句为例）
```java
Connection conn = dataSource.getConnection();
Statement statement = conn.createStatement();
statement.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
```

2) executeUpdate

```java
ShardingStatement$executeUpdate()
  //
  clearPrevious();
  //
  sqlRoute(sql);
    new StatementRoutingEngine(...).route(sql);
      //使用SQLParsingEngine解析SQL语句，了解参考：官方文档“解析引擎”
      //主要是进行词法和语法解析获取抽象语法树，并结合分片配置标识可能需要更改的地方
      //SQLStatement就是解析优化之后的Statement实现类
      SQLStatement sqlStatement = shardingRouter.parse(logicSQL, false);
      //先进行分片路由，再执行主从路由
      masterSlaveRouter.route(shardingRouter.route(logicSQL, Collections.emptyList(), sqlStatement));
        //使用雪花算法计算分片主键id
        getGenerateKey(shardingRule, (InsertStatement) sqlStatement, parameters)
        //实例化优化引擎对sql进行优化
        OptimizeEngineFactory.newInstance(...).optimize()
        //使用分片路由的StandardRoutingEngine以及SQLRewriteEngine对逻辑表的insert语句进行重写，生成对物理表的insert语句，以及路由目标物理数据库
        RoutingEngineFactory.newInstance(...).route()
        new SQLRewriteEngine(...).rewrite(routingResult.isSingleRouting()); 
        //然后执行ShardingMasterSlaveRouter.route(),读取MasterSlaveRule决定将SQL发送到Master还是Slave执行
        new ShardingMasterSlaveRouter.route()
  //初始化Statement执行器
  initStatementExecutor();
    //
    statementExecutor.init(routeResult);
    replayMethodForStatements();
  //
  statementExecutor.executeUpdate(autoGeneratedKeys);
```

### SQLParsingEngine

用于将SQL语句解析成抽象语法树，并结合分片配置标识可能需要更改的地方，关于抽象语法树参考《编译原理-抽象语法树.md》。

![](https://shardingsphere.apache.org/document/legacy/3.x/document/img/sharding/parsing_architecture_cn.png)

+ SQLStatement


### OptimizeEngine

+ InsertOptimizeEngine

+ QueryOptimizeEngine

### RoutingEngine

![](https://shardingsphere.apache.org/document/legacy/3.x/document/img/sharding/route_architecture_en.png)

SQL中携带分片键走ShardingRoute，否则走BroadcastRoute。

这些路由使用的场景具体都是什么样的？

### SQLRewriteEngine

### 

### 合并引擎

![归并引擎工作流程图](https://shardingsphere.apache.org/document/legacy/3.x/document/img/sharding/merge_architecture_cn.png)

+ **排序归并**

  实现原理：使用优先级队列